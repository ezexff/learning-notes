# Theses

Ниже приведены цитаты хороших программистов

## Casey Muratori

* ALWAYS WRITE THE USAGE CODE FIRST!!!

* Цель HMH это научить как непосредственно писать код на лоу уровне фишек игрового движка, а так же как делать множество вещей: треды, очереди работ, simd и т.д. с которыми обычно не сталкиваешься, когда делаешь игру на готовом движке или на высоком уровне по типу js. Т.е. HMH learn how to be an engine programmer and low level programmer

* Огромная пропасть/разница между тем как мы можем себе представить решение проблемы в голове и тем как проблему решает CPU!!!

* Сравнение C и C++ с Java, C#, Python
  * При программировании на C и C++ и компилировании в бинарный вид, то в игре будет происходить всё так как вы накодили (не считая видео драйвера и т.д.)
  * При программировании на Java, C#, Python и т.д. могут возникать проблемы из-за ядра, т.к. у нас к нему нет доступа. Например, проблемы связанные с виртуальной машиной, сборщиком мусора и т.д.

* ООП это плохо, т.к. программировать это давать процессору команды. В процессоре нет концепта ООП. Т.е. программирование о выяснении того, что нужно сделать процессору для решение проблемы, а при программировании с использованием ООП ты думаешь не о решении проблемы на аппаратном уровне, а об инкапсуляции, что противоречит логике работы процессора

* Стандартные библиотеки C это плохо
  * Они делают много лишней нежелательной работы. Пример math.h и математические функции sin() atan()
  * Плохой API, например, файловый, т.к. нельзя одновременно выполнить fseek и fwrite (в c write to file api это отдельные команды). Подобная тема ужасна при многопоточности, например, когда несколько пользователей работает с одним файлом. Одновременный fseek в разных потоках будет вызывать неправильный результат записи fwrite. В нормальной системе тебе хочется всегда указывать location и size для записи в файл
  * Часто возникает ситуация, когда на компьютере нет определённой версии C Runtime Library из-за чего программа не запускается

* STL очень плоха и одна из худших вещей этой библиотеки это строки (strings)

* API для GUI Windows apps
  * Qt - плохой, не нужно использовать
  * ImGui - норм

* Нет смысла беспокоиться о том что код не cache-friendly, когда не знаешь исполняется ли этот код часто. Это как в вопросе с оптимизацией. Преждевременная оптимизация бессмысленна

* Единственное отличие структур от классов в C++ это public и private, а так они одинаковы

* new / delete - одна из самых глупых вещей в C++. Их придётся вызывать, если используешь виртуальную функцию

* Какой графический API использовать? Все графические API имеет много проблем, но если выбирать, то
  * Windows - Direct3D т.к. native
  * Mac - Metal API
  * для кроссплатформы (раньше) - OpenGL, но не лучший вариант для Windows и с 18 года не поддерживается на Маке

* The Thirty Million Line Problem - за последние 20 лет аппаратная часть ЭВМ стала во много раз производительнее, а качество кода сильно ухудшилось

* Какую ценность имеет университет в становлении программистом? Никакую! Это максимально бесполезно. Это может может помочь найти работу, но никак не поможет быть программистом. Для hr (ректутеров) диплом может быть важен

* Большинство современного ПО это машина Руба Голдберга

* I like sometimes use Sean Barrett libraries because they are good (stb)

* stb библиотеки хороши, т.к. помогают сэкономить время, чего не скажешь про другие библиотеки, у которых много проблем, например, плохой API на изучение которого может уйти много времени

* плюсы, когда не используешь библиотеки в мейн коде
  * портируемость
  * надёжность
  * эффективность и т.д.

* обычно проблемы возникают, когда пользователи используют библиотеки, которые они не понимают и это ужасно, т.к. они не знают почему библиотека быстрая/медленная, есть в ней баги, может ли она быть портирована и т.д.

* увы, но если ты понимаешь что делаешь, то большинство библиотек делают ту или иную вещь хуже, чем это мог бы сделать ты сам

* Debug Infrastructure - Test-driven development doesn't help solving the harder problems of game programming

* Q: Важно ли знание алгоритмов и структур данных? A: Знание реализаций структур данных, алгоритмов не особо важно, но вот знание того какие есть алгоритмы, структуры данных и когда их можно использовать крайне необходимо

* Почему ты используешь Windows? https://store.steampowered.com/hwsurvey/Steam-Hardware-Software-Survey-Welcome-to-Steam 24.10.14 - доля пользователей Windows 96.84% от общего числа игроков

* Про Линукс https://youtu.be/fduWZsh1riQ?t=8340

* exploration coding: try do smth and then think which way better. не думать о том, чтобы сразу писать код, который будет использоваться, а действовать методом исследования (пробовать реализовать разные варианты и на основе результатов принимать решение о том, что лучше)

*  Для лучшей производительности надо упаковывать данные не по одинаковым типам, а по доступу к данным. spatial locality is just about keeping data used together close together

*  если при попытке в программировании понять ту или юную вещь она тебя пугает, то это не твоя проблема, а проблема разработчика, т.е. это не твоя проблема, что тебе приходится разбираться в плохой системе, в css, html, java script - ты не программируешь, а используешь "теги" css, html, java script - ужасны и это проблема создателей. frontend - не является простым, т.к. так называемых тегов невероятно много и решение простых проблем требует "костылей" по типу выравнивания по центру

*  программирование на бейсике - просто, т.к. имеет небольшой список команд, которые интуитивно понятны

*  Google - огромнейшая корпорация, но при этом во всех своих сервисах имеет множество ошибок (java script errors, оформление, выравнивание, текстовые и т.д.). у вас профессионалы со всего мира, миллионы долларов, но возникают ошибки по типу невидимого диалогового окна "you can subscribe", которая блокирует скролинг если вы сделали что-то легко, то это будет иметь много ошибок, т.к. сделано легко

*  польза университета для программиста - никакая. для программиста портфолио во много раз лучше диплома

*  язык ассемблера важно знать, чтобы понимать что делает компилятор с кодом, который ты пишешь

*  Лучше всего сначала пытаться решить проблему, не думаю о наилучшем способе и когда проблема будет решена, скорее всего далеко не самым оптимальным способом, то только тогда имеет смысл рассматривать варианты улучшения и т.д.

*  преждевременная оптимизация - зло

*  указатель указывает на переменную в памяти, т.е. хранят в себе адрес переменной в памяти, сам адрес можно получить при помощи унарного оператора &. ссылка это новое дополнительное имя переменной &x — это адрес x в памяти, а *ptr — это значение, живущее по адресу, записанному в ptr.

*  совет для изучения программирования: пытайтесь думать как CPU решает проблему

*  don't write usage code first: don't think about api and structures

*  size_t used when you don't know about x32 or x64 platform for smth in memory

*  прототипирование, проектирование и т.д. мёртворождённая тема, т.к. нужно думать о том как CPU решашит проблему, а это возможно лишь при написании рабочего кода

*  шейдеры отличная архитектура, т.к. позволяет минимизировать обращение к памяти и следовательно увеличить пропускную способность видеокарты

## Fabian Giesen

* Читать код это сложно

## Jonathan Blow

* Главная проблема в программировании при работе над большими проектами с огромным числом людей - координация. Все локально выполняют задачу исходя из своего видения

* Многие вещи очень простые, но несмотря на это, очень сложно найти верную информацию об этих вещах